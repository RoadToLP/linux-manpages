.TH "bitmap_find_next_zero_area_off" 9 "bitmap_find_next_zero_area_off" "May 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
bitmap_find_next_zero_area_off \- find a contiguous aligned zero area
.SH SYNOPSIS
.B "unsigned long" bitmap_find_next_zero_area_off
.BI "(unsigned long *map "  ","
.BI "unsigned long size "  ","
.BI "unsigned long start "  ","
.BI "unsigned int nr "  ","
.BI "unsigned long align_mask "  ","
.BI "unsigned long align_offset "  ");"
.SH ARGUMENTS
.IP "map" 12
The address to base the search on
.IP "size" 12
The bitmap size in bits
.IP "start" 12
The bitnumber to start searching at
.IP "nr" 12
The number of zeroed bits we're looking for
.IP "align_mask" 12
Alignment mask for zero area
.IP "align_offset" 12
Alignment offset for zero area.
.SH "DESCRIPTION"
The \fIalign_mask\fP should be one less than a power of 2; the effect is that
the bit offset of all zero areas this function finds plus \fIalign_offset\fP
is multiple of that power of 2.
