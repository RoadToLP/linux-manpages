.TH "xenbus_watch_path" 9 "xenbus_watch_path" "May 2021" "Kernel Hacker's Manual" LINUX
.SH NAME
xenbus_watch_path \- register a watch
.SH SYNOPSIS
.B "int" xenbus_watch_path
.BI "(struct xenbus_device *dev "  ","
.BI "const char *path "  ","
.BI "struct xenbus_watch *watch "  ","
.BI "bool (*will_handle)(struct xenbus_watch *, const char *, const char *) "  ","
.BI "void (*callback)(struct xenbus_watch *, const char *, const char *) "  ");"
.SH ARGUMENTS
.IP "dev" 12
xenbus device
.IP "path" 12
path to watch
.IP "watch" 12
watch to register
.IP "will_handle" 12
-- undescribed --
.IP "callback" 12
callback to register
.SH "DESCRIPTION"
Register a \fIwatch\fP on the given path, using the given xenbus_watch structure
for storage, and the given \fIcallback\fP function as the callback.  Return 0 on
success, or -errno on error.  On success, the given \fIpath\fP will be saved as
\fIwatch->node\fP, and remains the caller's to free.  On error, \fIwatch->node\fP will
be NULL, the device will switch to XenbusStateClosing, and the error will
be saved in the store.
